#ifdef VS 
 
precision highp float;
attribute vec3 position;
attribute vec3 normal;
uniform mat3 normalMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
varying vec3 fNormal;
varying vec3 fPosition;

uniform float time;

const float pi=3.14159;

//const float strength = 0.7;
const float blurriness = 2.0;
const float stillness = 2.0;
const float refract_idx = 1.0 / 1.3333;

varying vec3 modelX;
varying vec3 modelN;
varying vec3 rawX;

// src start
// reference: https://github.com/yiwenl/glsl-fbm
#define NUM_OCTAVES 5

float rand(vec2 n) { 
  return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
}

float noise(vec2 p){
  vec2 ip = floor(p);
  vec2 u = fract(p);
	u = u*u*(3.0-2.0*u);
	
	float res = mix(
		mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),
		mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);
	return res*res;
}

float fbm(vec2 x) {
	float v = 0.0;
	float a = 0.5;
	vec2 shift = vec2(100);
	// Rotate to reduce axial bias
    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
	for (int i = 0; i < NUM_OCTAVES; ++i) {
		v += a * noise(x);
		x = rot * x * 2.0 + shift;
		a *= 0.5;
	}
	return v;
}
// src end

vec2 Floating2D(vec2 vec_in, float t)
{
  
  float strength = smoothstep(-0.15, 1.0, vec_in.x);
  
  vec2 surface = strength * vec2(
      mix(-0.3, 0.3, fbm(vec_in * blurriness + t * stillness)),
      mix(-0.3, 0.3, fbm(vec_in * blurriness + t * stillness))
  );
  
  vec_in += refract(vec2(0.0, 0.0), surface, refract_idx);
  
  return vec_in;
}

void main()
{
  modelX = position;
  rawX = position;
  modelN = normal;  
  
  // object transformation
  modelX.xy = Floating2D(modelX.xy, time * 2.5);
  modelX.xz = Floating2D(modelX.xz, time * 5.5);
  
  // light direction transformation
  modelN.xy = Floating2D(modelN.xy, time * 2.5);
  modelN.xz = Floating2D(modelN.xz, time * 5.5);
  
  // light position
  fNormal = normalize(normalMatrix * modelN);
  
  // object position with effect
  vec4 pos = modelViewMatrix * vec4(modelX, 1.0);
  fPosition = pos.xyz;
  gl_Position = projectionMatrix * pos;
}















 
#else 
 
precision highp float;
uniform float time;
uniform vec2 resolution;
varying vec3 fPosition;
varying vec3 fNormal;
varying vec3 rawX;

// src start
// reference: borrowed from lecture code
vec2 blinnPhongDir(vec3 lightDir, float lightInt, float Ka, float Kd, float Ks, float shininess)
{
  vec3 s = normalize(lightDir);
  vec3 v = normalize(-fPosition);
  vec3 n = normalize(fNormal);
  vec3 h = normalize(v+s);
  float diffuse = Ka + Kd * lightInt * max(0.0, dot(n, s));
  float spec =  Ks * pow(max(0.0, dot(n,h)), shininess);
  return vec2(diffuse, spec);
}
// src end

void main()
{
  float theta = time*20.0;
  
  // object
  vec3 object_color_right = vec3(0.5, 0.4, 0.4);
  vec3 object_color_left = vec3(0.8, 0.6, 0.6);
  
  // stationary light
  vec3 stationary_light_dir = vec3(0.0, 1.0, -1.0);
  vec3 stationary_light_color = vec3(0.2, 0.1, 0.2);
  
  // moving light
  vec3 moving_light_dir = vec3(-cos(theta),-0.8,-1.0);
  vec3 moving_light_color = vec3(0.4, 0.5, 0.8);
  
  vec3 stationary = blinnPhongDir(
    stationary_light_dir, // light direction
    0.0,                  // lightInt
    0.0,                  // Ka
    0.0,                  // Kd
    1.0,                  // Ks
    1.0                   // shiness
  ).y * stationary_light_color;
  
  vec3 moving = blinnPhongDir(
    moving_light_dir,     // light direction
    0.0,                  // lightInt
    0.0,                  // Ka
    0.0,                  // Kd
    1.0,                  // Ks
    1.0                   // shiness
  ).y * moving_light_color;
  
  vec3 object_r = blinnPhongDir(
    stationary_light_dir, // light direction
    4.0,                  // lightInt
    0.15,                 // Ka
    0.7,                  // Kd
    0.0,                  // Ks
    1.0                   // shiness
  ).x * object_color_right;
  
  vec3 object_l = blinnPhongDir(
    stationary_light_dir, // light direction
    1.0,                  // lightInt
    0.55,                 // Ka
    0.7,                  // Kd
    0.0,                  // Ks
    1.0                   // shiness
  ).x * object_color_left;
  
  if(tan(100.0*rawX.y)>0.9) discard;
  if(tan(100.0*rawX.x)>0.9) discard;
  
  gl_FragColor = vec4(stationary + moving + object_l, 1.0);
  if(100.0*rawX.x > 0.0) gl_FragColor = vec4(stationary + moving + object_r, 0.1);
}


 
#endif